export class EventEmitter{constructor(){this._events=new Map}_addListener(e,t,s){this.emit("newListener",e,t);if(this._events.has(e)){const r=this._events.get(e);if(s){r.unshift(t)}else{r.push(t)}}else{this._events.set(e,[t])}const r=this.getMaxListeners();if(r>0&&this.listenerCount(e)>r){const t=new Error(`Possible EventEmitter memory leak detected.\n         ${this.listenerCount(e)} ${e.toString()} listeners.\n         Use emitter.setMaxListeners() to increase limit`);t.name="MaxListenersExceededWarning";console.warn(t)}return this}addListener(e,t){return this._addListener(e,t,false)}emit(e,...t){if(this._events.has(e)){if(e==="error"&&this._events.get(EventEmitter.errorMonitor)){this.emit(EventEmitter.errorMonitor,...t)}const s=this._events.get(e).slice();for(const e of s){try{e.apply(this,t)}catch(e){this.emit("error",e)}}return true}else if(e==="error"){if(this._events.get(EventEmitter.errorMonitor)){this.emit(EventEmitter.errorMonitor,...t)}const e=t.length>0?t[0]:Error("Unhandled error.");throw e}return false}eventNames(){return Array.from(this._events.keys())}getMaxListeners(){return this.maxListeners||EventEmitter.defaultMaxListeners}listenerCount(e){if(this._events.has(e)){return this._events.get(e).length}else{return 0}}_listeners(e,t,s){if(!e._events.has(t)){return[]}const r=e._events.get(t);return s?this.unwrapListeners(r):r.slice(0)}unwrapListeners(e){const t=new Array(e.length);for(let s=0;s<e.length;s++){t[s]=e[s]["listener"]||e[s]}return t}listeners(e){return this._listeners(this,e,true)}rawListeners(e){return this._listeners(this,e,false)}off(e,t){return this.removeListener(e,t)}on(e,t){return this.addListener(e,t)}once(e,t){const s=this.onceWrap(e,t);this.on(e,s);return this}onceWrap(e,t){const s=function(...e){this.context.removeListener(this.eventName,this.rawListener);this.listener.apply(this.context,e)};const r={eventName:e,listener:t,rawListener:s,context:this};const n=s.bind(r);r.rawListener=n;n.listener=t;return n}prependListener(e,t){return this._addListener(e,t,true)}prependOnceListener(e,t){const s=this.onceWrap(e,t);this.prependListener(e,s);return this}removeAllListeners(e){if(this._events===undefined){return this}if(e&&this._events.has(e)){const t=this._events.get(e).slice();this._events.delete(e);for(const s of t){this.emit("removeListener",e,s)}}else{const e=this.eventNames();e.map(e=>{this.removeAllListeners(e)})}return this}removeListener(e,t){if(this._events.has(e)){const s=this._events.get(e);if(s==undefined){return this}let r=-1;for(let e=s.length-1;e>=0;e--){if(s[e]==t||s[e]&&s[e]["listener"]==t){r=e;break}}if(r>=0){s.splice(r,1);this.emit("removeListener",e,t);if(s.length===0){this._events.delete(e)}}}return this}setMaxListeners(e){this.maxListeners=e;return this}}EventEmitter.defaultMaxListeners=10;EventEmitter.errorMonitor=Symbol("events.errorMonitor");const events=new EventEmitter;events.setMaxListeners(1<<10);export default events;